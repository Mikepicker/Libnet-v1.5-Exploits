#include <libnet.h>
#include <pcap.h>
#include "hacking.h"

#define MAX_EXISTING_PORTS 30

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
int set_packet_filter(pcap_t *, struct in_addr *, u_short *);

int main(int argc, char *argv[]) {
	// pcap fields
	struct pcap_pkthdr cap_header;
	pcap_t *pcap_handle;
	char *device;
	u_long target_ip;
	int i;

	// libnet fields
	libnet_t *libnet_context;
	u_char errbuf[LIBNET_ERRBUF_SIZE];

	u_short existing_ports[MAX_EXISTING_PORTS];

	// args check
	if((argc < 2) || (argc > MAX_EXISTING_PORTS+2)) 
	{
		if(argc > 2)
			printf("Limited to tracking %d existing ports.\n", MAX_EXISTING_PORTS);
		else
			printf("Usage: %s <IP to shroud> [existing ports...]\n", argv[0]);
		exit(0);
	}

	// Init libnet context
	libnet_context = libnet_init(LIBNET_RAW4, NULL, errbuf);
	if ( libnet_context == NULL )
	{
		fprintf(stderr, "libnet_init() failed: %s\n", errbuf);
		exit(EXIT_FAILURE);
	}

	// Resolve target ip
	target_ip = libnet_name2addr4(libnet_context, argv[1], LIBNET_RESOLVE);
	if (target_ip == -1)
		fatal("Invalid target address");
	
	for(i=2; i < argc; i++)
		existing_ports[i-2] = (u_short) atoi(argv[i]);
	
	existing_ports[argc-2] = 0;

	device = pcap_lookupdev(errbuf);
	if(device == NULL)
		fatal(errbuf);

	pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);
	if(pcap_handle == NULL)
		fatal(errbuf);

	libnet_seed_prand(libnet_context); // seed the random number generator 

	set_packet_filter(pcap_handle, (struct in_addr *)&target_ip, existing_ports);

	pcap_loop(pcap_handle, -1, caught_packet, (u_char *)libnet_context);

	pcap_close(pcap_handle);
}

void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet)
{
	u_char *pkt_data;
	struct libnet_ipv4_hdr *IPhdr;
	struct libnet_tcp_hdr *TCPhdr;
	libnet_t *libnet_context;
	int byte_count;

	libnet_context = (libnet_t *) user_args; // pass data using a pointer to a struct 

	IPhdr = (struct libnet_ipv4_hdr *) (packet + LIBNET_ETH_H);
	TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);

	printf("DEBUG: Building tcp header..\n");
	libnet_build_tcp(htons(TCPhdr->th_dport),// source TCP port (pretend we are dst) 
	 htons(TCPhdr->th_sport),        // destination TCP port (send back to src) 
	 htonl(TCPhdr->th_ack),          // sequence number (use previous ack) 
	 libnet_get_prand(LIBNET_PRu32), // acknowledgement number (randomized) 
	 TH_SYN | TH_ACK,                // control flags 
	 libnet_get_prand(LIBNET_PRu16), // window size (randomized)
	 0,				 // checksum (0 autofill)
	 0,                              // urgent pointer
	 LIBNET_TCP_H,	 		 // tcp packet length 
	 NULL,                           // payload (none) 
	 0,                              // payload length
	 libnet_context,		 // libnet context
	 0);				 // ptag

	printf("DEBUG: Building ipv4 header..\n");
	libnet_build_ipv4(LIBNET_IPV4_H + LIBNET_TCP_H,    // size of the packet sans IP header 
	 IPTOS_LOWDELAY,                 // IP tos 
	 libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) 
	 0,                              // frag stuff 
	 libnet_get_prand(LIBNET_PR8),   // TTL (randomized) 
	 IPPROTO_TCP,                    // transport protocol
	 0,				 // checksum (0 autofill)
	 *((u_long *)&(IPhdr->ip_dst)),  // source IP (pretend we are dst) 
	 *((u_long *)&(IPhdr->ip_src)),  // destination IP (send back to src) 
	 NULL,                           // payload (none) 
	 0,                              // payload length
	 libnet_context,		 // libnet context
	 0);               		 // ptag 

	printf("DEBUG: Injecting packet..\n");
	byte_count = libnet_write(libnet_context); // inject packet
	if (byte_count != -1)
		printf("%d bytes written.\n", byte_count);
	else if (byte_count < LIBNET_IPV4_H + LIBNET_TCP_H)
		printf("Warning: Incomplete packet written.\n");
	else
		fprintf(stderr, "Error writing packet: %s\n",\
		libnet_geterror(libnet_context)); 
		
	libnet_clear_packet(libnet_context);	// clear packet
	printf("bing!\n");
}

/* Sets a packet filter to look for established TCP connections to target_ip */
int set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip, u_short *ports)
{
	struct bpf_program filter;
	char *str_ptr, filter_string[90 + (25 * MAX_EXISTING_PORTS)];
	int i=0;

	sprintf(filter_string, "dst host %s and ", inet_ntoa(*target_ip)); // Target IP
	strcat(filter_string, "tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack = 0");

	if(ports[0] != 0)	// If there is at least one existing port
	{ 
		str_ptr = filter_string + strlen(filter_string);
		if(ports[1] == 0) // There is only one existing port
			sprintf(str_ptr, " and not dst port %hu", ports[i]);
		else 	// Two or more existing ports
		{ 
			sprintf(str_ptr, " and not (dst port %hu", ports[i++]);
			while(ports[i] != 0)
			{
				str_ptr = filter_string + strlen(filter_string);
				sprintf(str_ptr, " or dst port %hu", ports[i++]);
			}
			strcat(filter_string, ")");
		}
	}

	printf("DEBUG: filter string is \'%s\'\n", filter_string);
	if(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)
		fatal("pcap_compile failed");
	
	if(pcap_setfilter(pcap_hdl, &filter) == -1)
		fatal("pcap_setfilter failed");
}
